#!/usr/bin/env bash

set -e

# Colors
W='\e[1;39m' # White
R='\033[1;31m' # Red
G='\033[1;32m' # Green
B='\033[1;34m' # Blue
Y='\033[1;33m' # Yellow
NC='\033[0m' # No color

main() {
  local arg="$1"

  case ${arg} in
    -h|--help)
      show_help
      exit
      ;;
    *)
      [ $EUID -ne 0 ] && \
        echo -e "${R}==>${NC} Please run booster-um as ${R}root${NC}." >&2 && exit 1
      ;;
  esac

  # Common paths
  CMDLINE=/etc/kernel/cmdline
  SPLASH=/usr/share/systemd/bootctl/splash-arch.bmp

  # Configs
  CONFIG=/etc/booster-um.yaml
  BOOSTER_CONFIG=/etc/booster.yaml

  # EFI dir path
  _set_efi_path

  # Trigger any potential automounts
  stat -- /boot /efi "$EFI_DIR" &>/dev/null || :

  # Find all installed kernels
  _find_kernels

  case "${arg}" in
    -g)
      # Generate UKI file for specified kernel package name
      _generate_kernel_uki "$2"
      ;;
    -r)
      # Remove UKI file for specified kernel package name
      _remove_uki "$2"
      ;;
    -G)
      # Generate UKI files for all kernels
      _generate_all_files
      ;;
    -R)
      # Remove booster*, vmlinuz* and UKI files for all installed kernels
      # -F argument removes mentioned files + other initramfs* files and whole esp/EFI/Linux dir
      _remove_all_files "$2"
      ;;
    -u)
      # This argument is used in libalpm hook
      # Generate UKI file on kernel update
      # Do not sign the UKI file if it exists in the sbctl database
      _generate_fallback_initramfs "$2" "$3"
      _generate_uki "$2" "$3" .
      ;;
    -U)
      # This argument is used in libalpm hook
      # Generate UKI files for all installed kernels
      _generate_all_files .
      ;;
    *)
      echo -e "${R}==>${NC} Unknown parameter ${R}$arg${NC} passed." >&2
      show_help && exit 1
      ;;
  esac
}

show_help() {
local command_name="${0##*/}"
cat << EOF
Usage: $command_name [OPTIONS] <package>

Generate or remove booster UKI files.

Help options:
    -h, --help  Show this help message

Generate options:
    -g package  generate UKI file for specified kernel package name
    -G          generate UKI files for all installed kernels

Remove options:
    -r package  remove UKI file for specified kernel package name
    -R          remove all known booster-*, vmlinuz-* files from /boot and all known files from esp/EFI/Linux dir
    -R -F       remove all mentioned files + other initramfs* files from /boot and whole esp/EFI/Linux dir

Examples: $command_name -g linux
          $command_name -r linux
          $command_name -G
          $command_name -R
          $command_name -R -F
EOF
}

# Checks if the package name is actually a kernel package name
_check_pkgbase() {
  local pkgbase="$1"
  if ! printf '%s\0' "${pkgbases[@]}" | grep -Fqxz -- "$pkgbase"; then
    echo -e "${R}Invalid kernel package name.${NC}" >&2 && exit 1
  fi
}

# Sets EFI dir path
_set_efi_path() {
  local esp_path boot_path
  esp_path="$(bootctl -p)"
  boot_path="$(bootctl -x)"

  if [ "$esp_path" != "$boot_path" ]; then
    local boot_disk part_guid xbootldr_guid
    xbootldr_guid="bc13c2ff-59e6-4262-a352-b275fd6f7172"
    boot_disk="$(findmnt -nreo source ${boot_path})"
    part_guid="$(lsblk -lno PARTTYPE ${boot_disk})"

    if [[ "$part_guid" == "$xbootldr_guid" ]]; then
      EFI_DIR="${boot_path}/EFI/Linux"
      return
    fi
  fi

  EFI_DIR="${esp_path}/EFI/Linux"
}

# Find out all package names of installed kernels
_find_kernels() {
  kernels=()
  readarray -t -O "${#kernels[@]}" kernels < <(find /usr/lib/modules \
    -maxdepth 1 \
    ! -path '*/\.*' -type d \
    ! -name 'modules' \
    -exec sh -c 'for path; do if pacman -Qqo -- "$path/pkgbase" > /dev/null 2>&1; then echo $path; fi; done' _ {} +)

  # Generate array of valid kernel package names
  readarray -t pkgbases < <(printf '%s/pkgbase\n' "${kernels[@]}" | xargs -I {} cat {})
}

# Checks if file is in sbctl database
_in_db() {
  sbctl list-files --json | yq -r '.[].file' | grep -qw "$1"
}

# Check if sbctl command exists
_sbctl_exists() {
  command -v -- sbctl > /dev/null 2>&1
}

# Checks if the creation of universal images is enabled
_is_universal() {
  [[ ! -e "$BOOSTER_CONFIG" ]] && return 1
  yq '.universal == true' "$BOOSTER_CONFIG" | grep -Fqwx -- 'true'
}

# Checks if the booster-um should always generate a fallback UKI
_should_generate_fallback() {
  [[ ! -e "$CONFIG" ]] && return 1
  yq '.generate_fallback == true' "$CONFIG" | grep -Fqwx -- 'true'
  if [[ $? -eq 0 ]] && ! _is_universal; then
    return
  fi;
  false
}

# Checks if the booster-um should always sign generated UKI
_should_sign_uki() {
  [[ ! -e "$CONFIG" ]] && return
  yq '.sign_uki == false' "$CONFIG" | grep -Fqwx -- 'true'
  if [[ $? -eq 1 ]]; then
    return
  fi;
  false
}

# Checks if the booster-um should remove leftovers (vmlinuz and initramfs)
_should_remove_leftovers() {
  [[ ! -e "$CONFIG" ]] && return
  yq '.remove_leftovers == false' "$CONFIG" | grep -Fqwx -- 'true'
  if [[ $? -eq 1 ]]; then
    return
  fi;
  false
}

# Basic function, generates one UKI
_generate_uki() {
  # arguments
  local pkgbase="$1"
  local sign="$3"

  # systemd-ukify paths
  local UCODE UNAME VMLINUZ UKI
  UNAME="$2"

  echo -e "${B}==>${NC} Generating UKI for ${G}${pkgbase}${NC}..."

  # ucode
  mapfile -d '' ucodes < <(find /boot -name '*-ucode.img' -type f -print0)
  [[ ${#ucodes[@]} -gt 1 ]] && echo "${R}==>${NC} Mutlitple microcode images detected, please use one!" >&2 && exit 1
  UCODE="${ucodes[0]}"

  # vmlinuz
  VMLINUZ="/boot/vmlinuz-${pkgbase}"
  [[ ! -e "$VMLINUZ" ]] && {
    echo -e "${R}==>${NC} Unable to find compressed kernel image, ${R}vmlinuz-${pkgbase}${NC}" >&2
    echo -e "${R}==>${NC} Regenerate kernel files with ${G}booster-um -g ${pkgbase}${NC} or use ${G}booster-um -G${NC} to regenerate files for all kernels" >&2
  } && exit 1

  # initramfs
  local initramfs=( "/boot/booster-${pkgbase}.img" )
  if _should_generate_fallback; then
    initramfs+=( "/boot/booster-${pkgbase}-fallback.img" )
  fi

  # cmdline
  [[ ! -e "$CMDLINE" ]] && cp /proc/cmdline "$CMDLINE"

  # UKI file path
  [[ ! -e "$EFI_DIR" ]] && mkdir -p "$EFI_DIR"
  local uki="${EFI_DIR}/arch-${pkgbase}"

  for initrd_id in "${!initramfs[@]}"; do
    local INITRD="${initramfs[initrd_id]}"
    [[ ! -e "$INITRD" ]] && echo -e "${R}==>${NC} Unable to find ${INITRD}${NC}." >&2 && exit 1

    # Set UKI fallback path
    [[ initrd_id -gt 0 ]] && uki="${uki}-fallback"

    # Set UKI path
    UKI="${uki}.efi"

    # Build UKI file
    /usr/lib/systemd/ukify build \
      --uname="${UNAME}" \
      --linux="${VMLINUZ}" ${UCODE:+"--initrd=$UCODE"} \
      --initrd="${INITRD}" \
      --cmdline=@"${CMDLINE}" \
      --splash="${SPLASH}" \
      --output="${UKI}" | tail -n 1

    # Continue if sbctl is not installed
    if ! _sbctl_exists || ! _should_sign_uki; then continue; fi

    if [ "${sign:=-s}" != "-s" ]; then
      # Sbctl hook should sign the UKI file if it already exists in database
      if _in_db "$UKI"; then continue; fi
    fi

    # Sign UKI file with sbctl
    sbctl sign --save "$UKI" || :
  done

  # Remove the leftovers (vmlinuz and booster initramfs)
  if _should_remove_leftovers; then
    rm -f "$VMLINUZ" "${initramfs[@]}"
  fi
}

# Generates UKI file for specified kernel package name
_generate_kernel_uki() {
  local pkgbase="$1"
  _check_pkgbase "$pkgbase"

  local sign="$2"

  # Get the index of pkgbase
  index="$(printf "%s\n" "${pkgbases[@]}" | grep -n "^${pkgbase}$" | sed "s/:${pkgbase}//")"
  local kernel="${kernels[$((index-1))]}"

  # Generate booster initramfs
  _generate_initramfs "$kernel"

  # Generate and sign UKI file
  _generate_uki "$pkgbase" "$uname" "$sign"
}

# Generates UKI files for all installed kernels
_generate_all_uki() {
  local uname
  local sign="$1"
  for kernel in "${kernels[@]}"; do
    read -r pkgbase < "${kernel}/pkgbase"

    uname="${kernel##/usr/lib/modules/}"

    # Generate and sign UKI file
    _generate_uki "$pkgbase" "$uname" "$sign"
  done
}

_regenerate_images() {
  # Generate initramfs and fallback initramfs
  for kernel in "${kernels[@]}"; do
    _generate_initramfs "$kernel" &
  done

  # Wait for all background jobs
  wait
}

# Generate initramfs for specified kernel path
_generate_initramfs() {
  local kernel="$1"

  read -r pkgbase < "${kernel}/pkgbase"
  uname="${kernel##/usr/lib/modules/}"

  echo -e "${B}==>${NC} Generating initramfs for ${G}${pkgbase}${NC}..."

  # Install the vmlinuz
  install -Dm644 "${kernel}/vmlinuz" "/boot/vmlinuz-${pkgbase}"

  # Generate initramfs
  booster build --force --kernel-version "$uname" "/boot/booster-${pkgbase}.img"

  # Generate fallback initramfs
  _generate_fallback_initramfs "$pkgbase" "$uname"
}

# Generates fallback initramfs
_generate_fallback_initramfs() {
  local uname pkgbase
  pkgbase="$1"
  uname="$2"
  if _should_generate_fallback; then
    booster build --force --universal --kernel-version "$uname" "/boot/booster-${pkgbase}-fallback.img"
  fi
}

# Generates booster initramfs, vmlinuz and UKI files for all kernels
_generate_all_files() {
  local sign="$1"
  echo -e "${B}::${W} Generating initramfs for all installed kernels...${NC}"
  _regenerate_images
  echo -e "${B}::${W} Generating UKI files for all installed kernels...${NC}"
  _generate_all_uki "$sign"
}

# Removes sbctl file database completely
# Removes all known booster initramfs, vmlinuz and UKI files
# With -F argument it removes all initramfs-*, booster-*, vmlinuz-* files and esp/EFI/Linux dir
_remove_all_files() {
  local arg="$1"

  case "$arg" in
    -F)
      echo -e "${Y}==>${NC} Removing ${Y}all initramfs*, booster*, vmlinuz*${NC} files from ${Y}/boot${NC}..."

      # Remove all initramfs-*, booster-*,	 vmlinuz-* files
      rm -f /boot/{initramfs,booster,vmlinuz}*

      # Remove esp/EFI/Linux dir all its files from the sbctl database
      _remove_efi_dir
      ;;
    "")
      echo -e "${Y}==>${NC} Removing ${Y}all known booster and vmlinuz${NC} files from ${Y}/boot${NC}..."

      # Remove all vmlinuz and initramfs
      rm -f /boot/{booster,vmlinuz}-*

      # Remove all known UKI files from esp/EFI/Linux dir
      _remove_all_uki
      ;;
    *)
      echo -e "${R}==>${NC} Unknown parameter ${R}$arg${NC} passed." >&2 && exit
      ;;
  esac
  echo -e "${G}==>${NC} Done."
}

# Removes all known UKI files from esp/EFI/Linux dir
_remove_all_uki() {
  shopt -s nullglob

  echo -e "${Y}==>${NC} Removing ${Y}all known UKI${NC} files from ${Y}${EFI_DIR}${NC} dir..."

  # Store all UKI files in array
  local uki_files=("${EFI_DIR}"/arch-*.efi)

  for uki_file in "${uki_files[@]}"; do
    rm -f "$uki_file"
    # Remove the UKI file from sbctl database
    if _sbctl_exists; then sbctl remove-file "$uki_file" || :; fi
  done

  shopt -u nullglob
}

# Removes esp/EFI/Linux dir all its files from the sbctl database
_remove_efi_dir() {
  shopt -s nullglob

  # Store all EFI files in array
  local efi_files=("${EFI_DIR}"/*.efi)

  if _sbctl_exists; then
    for efi_file in "${efi_files[@]}"; do
      # If EFI file exists in sbctl database, remove it
      if _in_db "$efi_file"; then
        # Remove EFI file from sbctl database
        sbctl remove-file "$efi_file" || :
      fi
    done
  fi

  echo -e "${Y}==>${NC} Removing ${Y}${EFI_DIR}${NC} dir..."

  # Remove esp/EFI/Linux dir
  rm -rf "$EFI_DIR"

  shopt -u nullglob
}

# Removes UKI file for specified kernel
_remove_uki() {
  local pkgbase="$1"
  _check_pkgbase "$pkgbase"

  # Store all UKI files in array
  readarray -t efi_files < <(find "${EFI_DIR}" \
    -type f \
    -name "arch-${pkgbase}.efi" -o \
    -name "arch-${pkgbase}-fallback.efi" 2> /dev/null)

  for efi_file in "${efi_files[@]}"; do
    echo -e "${Y}==>${NC} Removing ${Y}${efi_file}${NC} file..."
    if _in_db "$efi_file"; then
      # Remove EFI file from sbctl database
      sbctl remove-file "$efi_file" || :
    fi
    rm -f "$efi_file"
  done

  if _should_remove_leftovers; then
    rm -f /boot/{booster,vmlinuz}-"${pkgbase}"*
  fi
}

main "$@"; exit
