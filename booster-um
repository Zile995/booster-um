#!/usr/bin/env bash

set -e

# Colors
W='\e[1;39m'   # White
R='\033[1;31m' # Red
G='\033[1;32m' # Green
B='\033[1;34m' # Blue
Y='\033[1;33m' # Yellow
NC='\033[0m'   # No color

main() {
  local arg="$1"

  case ${arg} in
    -h|--help)
      show_help
      exit
      ;;
    *)
      [ $EUID -ne 0 ] &&
        echo -e "${R}==>${NC} Please run booster-um as ${R}root${NC}." >&2 && exit 1
      ;;
  esac

  # Common paths
  CMDLINE=/etc/kernel/cmdline
  SPLASH=/usr/share/systemd/bootctl/splash-arch.bmp

  # Configs
  CONFIG=/etc/booster-um.yaml
  BOOSTER_CONFIG=/etc/booster.yaml

  # Check booster-um config
  _check_config

  # EFI dir path
  _set_efi_path

  # Trigger any potential automounts
  stat -- /boot /efi "$EFI_DIR" &>/dev/null || :

  # Find all installed kernels
  _find_kernels

  # Flag which controls UKI signing
  sign=1

  # Flag which controls initramfs regeneration
  regenerate=0

  case "${arg}" in
    -g)
      # It will always regenerate initramfs
      # Generate UKI file for specified kernel package name
      shift
      regenerate=1
      _generate_kernel_uki "$1"
      ;;
    -r)
      # Remove UKI file (and leftovers by default) for specified kernel package name
      shift
      _remove_uki "$1"
      ;;
    -G)
      # Generate UKI files for all kernels
      # It will always regenerate initramfs
      _generate_all_files
      ;;
    -R)
      # Remove booster*, vmlinuz* and UKI files for all installed kernels
      # -F argument removes mentioned files + other initramfs* files and whole esp/EFI/Linux dir
      shift
      _remove_all_files "$1"
      ;;
    -u)
      # Generate UKI file on kernel update
      # This argument must be used only in libalpm hooks
      # UKI file will not be signed if it already exists in the sbctl database
      # It will not regenerate initramfs. Initramfs will be generated on kernel update by booster hook.
      shift
      sign=0
      _generate_fallback_initramfs "$1" "$2"
      _generate_uki "$1" "$2"
      ;;
    -U)
      # It will always regenerate initramfs
      # This argument is used in libalpm hook
      # Generate UKI files for all installed kernels
      sign=0
      _generate_all_files
      ;;
    *)
      echo -e "${R}==>${NC} Unknown parameter ${R}$arg${NC} passed." >&2
      show_help && exit 1
      ;;
  esac
}

show_help() {
  local command_name="${0##*/}"
  cat << EOF
Usage: $command_name [OPTIONS] <package>

Generate or remove booster UKI files.

Help options:
    -h, --help  Show this help message

Generate options:
    -g package  generate UKI file for specified kernel package name
    -G          generate UKI files for all installed kernels

Remove options:
    -r package  remove UKI file for specified kernel package name
    -R          remove all known booster-*, vmlinuz-* files from /boot and all known files from esp/EFI/Linux dir
    -R -F       remove all mentioned files + other initramfs* files from /boot and whole esp/EFI/Linux dir

Examples: $command_name -g linux
          $command_name -r linux
          $command_name -G
          $command_name -R
          $command_name -R -F
EOF
}

# Checks if the package name is actually a kernel package name
_check_pkgbase() {
  local pkgbase="$1"
  if ! printf '%s\0' "${pkgbases[@]}" | grep -Fqxz -- "$pkgbase"; then
    echo -e "${R}Invalid kernel package name.${NC}" >&2 && exit 1
  fi
}

# Sets EFI dir path
_set_efi_path() {
  local esp_path boot_path
  esp_path="$(bootctl -p)"
  boot_path="$(bootctl -x)"

  ESP_MOUNT="$esp_path"

  if [ "$esp_path" != "$boot_path" ]; then
    local boot_partition part_guid xbootldr_guid
    xbootldr_guid="bc13c2ff-59e6-4262-a352-b275fd6f7172"
    boot_partition="$(findmnt -nreo source "${boot_path}")"
    part_guid="$(partx -g -o TYPE "${boot_partition}")"

    if [[ "$part_guid" == "$xbootldr_guid" ]]; then
      ESP_MOUNT="$boot_path"
    fi
  fi

  EFI_DIR="${ESP_MOUNT}/EFI/Linux"
}

# Find out all package names of installed kernels
_find_kernels() {
  kernels=()
  readarray -t -O "${#kernels[@]}" kernels < <(find /usr/lib/modules \
    -maxdepth 1 \
    ! -path '*/\.*' -type d \
    ! -name 'modules' \
    -exec sh -c 'for path; do if pacman -Qqo -- "$path/pkgbase" > /dev/null 2>&1; then echo $path; fi; done' _ {} +)

  # Generate array of valid kernel package names
  readarray -t pkgbases < <(printf '%s/pkgbase\n' "${kernels[@]}" | xargs -I {} cat {})
}

# Checks if file is in sbctl database
_in_db() {
  sbctl list-files --json | yq -r '.[].file' | grep -qw "$1"
}

# Check if specified command exists
_command_exists() {
  command -v -- "$1" > /dev/null 2>&1
}

_check_config() {
  [[ ! -e "$CONFIG" ]] && config_valid=$((1-$?)) && return
  config_valid=$(yq --exit-status "$CONFIG" &>/dev/null; echo "$?")
  if [ "$config_valid" -ne 0 ]; then echo -e "${R}==>${NC} ${Y}$CONFIG${NC} config ${R}is not valid${NC}. ${Y}Default${NC} settings are used."; fi
}

# Checks if the creation of universal images is enabled
_is_universal() {
  [[ "$config_valid" -eq 1 ]] && return 1
  yq '.universal == true' "$BOOSTER_CONFIG" | grep -Fqwx -- 'true'
}

# Checks if the booster-um should always generate a fallback UKI
_should_generate_fallback() {
  [[ "$config_valid" -eq 1 ]] && return 1
  if yq '.generate_fallback == true' "$CONFIG" | grep -Fqwx -- 'true' && ! _is_universal; then return; fi
  false
}

# Checks if the booster-um should create EFI entry
_should_create_efi_entry() {
  [[ "$config_valid" -eq 1 ]] && return 1
  if yq '.efistub == true' "$CONFIG" | grep -Fqwx -- 'true'; then return; fi
  false
}

# Checks if the booster-um should create EFI entry
_should_preserve_boot_order() {
  [[ "$config_valid" -eq 1 ]] && return
  if ! yq '.efistub_config.preserve_boot_order == false' "$CONFIG" | grep -Fqwx -- 'true'; then return; fi
  false
}

# Checks if the booster-um should create EFI entry
_linux_always_first() {
  [[ "$config_valid" -eq 1 ]] && return
  if ! yq '.efistub_config.linux_always_first == false' "$CONFIG" | grep -Fqwx -- 'true'; then return; fi
  false
}

# Checks if the booster-um should always sign generated UKI
_should_sign_uki() {
  [[ "$config_valid" -eq 1 ]] && return
  if ! yq '.sign_uki == false' "$CONFIG" | grep -Fqwx -- 'true'; then return; fi
  false
}

# Checks if the booster-um should remove leftovers (vmlinuz and initramfs)
_should_remove_leftovers() {
  [[ "$config_valid" -eq 1 ]] && return
  if ! yq '.remove_leftovers == false' "$CONFIG" | grep -Fqwx -- 'true'; then return; fi
  false
}

# Basic function, generates one UKI
_generate_uki() {
  # arguments
  local pkgbase="$1"

  # systemd-ukify paths
  local UNAME VMLINUZ UKI INITRD
  UNAME="$2"

  echo -e "${B}==>${NC} Generating UKI for ${G}${pkgbase}${NC}..."

  # vmlinuz path
  VMLINUZ="/boot/vmlinuz-${pkgbase}"

  # initrd path
  INITRD="/boot/.initrd-${pkgbase}"

  # microcodes
  mapfile -d '' microcodes < <(find /boot -name '*-ucode.img' -type f -print0)

  # booster initramfs
  local booster_inits=("/boot/booster-${pkgbase}.img")
  if _should_generate_fallback; then
    booster_inits+=("/boot/booster-${pkgbase}-fallback.img")
  fi

  # Regenerate initramfs if specified
  [[ "$regenerate" -eq 1 ]] && _generate_initramfs "/usr/lib/modules/${UNAME}"

  # Generate initramfs if needed files doesn't exist
  if ! stat -- "${booster_inits[@]}" > /dev/null 2>&1 || [[ ! -e "$VMLINUZ" ]]; then
    _generate_initramfs "/usr/lib/modules/${UNAME}"
  fi

  # Copy the current cmdline if it doesn't exist
  [[ ! -e "$CMDLINE" ]] && cp /proc/cmdline "$CMDLINE"

  # UKI file path, create EFI dir if it doesn't exist
  [[ ! -e "$EFI_DIR" ]] && mkdir -p "$EFI_DIR"
  local uki_path="${EFI_DIR}/arch-${pkgbase}"

  for init_id in "${!booster_inits[@]}"; do
    local booster_initramfs="${booster_inits[init_id]}"

    # Create one initrd
    cat -- "${microcodes[@]}" "$booster_initramfs" > "$INITRD"

    # Set UKI fallback path
    [[ init_id -gt 0 ]] && uki_path="${uki_path}-fallback"

    # Set the UKI file with .efi exstension
    UKI="${uki_path}.efi"

    # Build the UKI file, sign it and create EFI entry
    /usr/lib/systemd/ukify build \
      --uname="${UNAME}" \
      --linux="${VMLINUZ}" \
      --initrd="${INITRD}" \
      --cmdline=@"${CMDLINE}" \
      --splash="${SPLASH}" \
      --output="${UKI}" | tail -n 1 && \
      _sign_uki "$UKI" && _create_efi_entry "$UKI"

    # Remove the old initrd after creating the UKI file
    rm -f "$INITRD"
  done

  # Remove the leftovers (vmlinuz and booster initramfs)
  _remove_leftovers "$pkgbase" 1
}

# Generates UKI file for specified kernel package name
_generate_kernel_uki() {
  local pkgbase="$1"
  _check_pkgbase "$pkgbase"

  # Get the index of pkgbase
  index="$(printf "%s\n" "${pkgbases[@]}" | grep -n "^${pkgbase}$" | sed "s/:${pkgbase}//")"
  local kernel="${kernels[$((index - 1))]}"

  local uname="${kernel##/usr/lib/modules/}"

  # Generate and sign UKI file
  _generate_uki "$pkgbase" "$uname"
}

# Generates UKI files for all installed kernels
_generate_all_uki() {
  local uname
  for kernel in "${kernels[@]}"; do
    read -r pkgbase < "${kernel}/pkgbase"
    uname="${kernel##/usr/lib/modules/}"

    # Generate and sign UKI file
    _generate_uki "$pkgbase" "$uname"
  done
}

# Generates initramfs and fallback initramfs
_regenerate_images() {
  local pids=()
  for kernel in "${kernels[@]}"; do
    _generate_initramfs "$kernel" & pids+=( $! )
  done

  # Wait for all background jobs
  for pid in "${pids[@]}"; do
    wait "$pid"
  done
}

# Generate initramfs for specified kernel path
_generate_initramfs() {
  local kernel="$1"
  read -r pkgbase < "${kernel}/pkgbase"
  local uname="${kernel##/usr/lib/modules/}"
  local vmlinuz="/boot/vmlinuz-${pkgbase}"
  local initramfs="/boot/booster-${pkgbase}.img"

  echo -e "${B}==>${NC} Generating initramfs for ${G}${pkgbase}${NC}..."

  # Install the vmlinuz
  install -Dm644 "${kernel}/vmlinuz" "$vmlinuz"

  # Generate initramfs
  booster build --force --kernel-version "$uname" "$initramfs" || (
    echo -e "${R}==>${NC} Unable to generate initramfs for ${R}${pkgbase}${NC}..."
    rm -f "$vmlinuz"
    exit 1
  )

  # Generate fallback initramfs
  _generate_fallback_initramfs "$pkgbase" "$uname"
}

# Generates fallback initramfs
_generate_fallback_initramfs() {
  local uname pkgbase
  pkgbase="$1"
  uname="$2"
  if _should_generate_fallback; then
    booster build --force --universal --kernel-version "$uname" "/boot/booster-${pkgbase}-fallback.img"
  fi
}

# Generates booster initramfs, vmlinuz and UKI files for all kernels
_generate_all_files() {
  echo -e "${B}::${W} Generating initramfs for all installed kernels...${NC}"
  _regenerate_images
  echo -e "${B}::${W} Generating UKI files for all installed kernels...${NC}"
  _generate_all_uki
}

# Removes the file from sbctl database
_remove_from_db() {
  local file="$1"

  # Return if sbctl doesn't exists
  if ! _command_exists sbctl; then return; fi

  # Remove the file if it exists in the database
  if _in_db "$file"; then
    # Remove the file from sbctl database
    sbctl remove-file "$file" || :
  fi
}

# Removes all known booster initramfs, vmlinuz and UKI files
# With -F argument it removes all initramfs-*, booster-*, vmlinuz-* files and esp/EFI/Linux dir
_remove_all_files() {
  local arg="$1"

  case "$arg" in
    -F)
      echo -e "${Y}::${NC} Removing ${Y}all initramfs*, booster*, vmlinuz*${NC} files from ${Y}/boot${NC}..."

      # Remove all initramfs-*, booster-*, vmlinuz-* files
      rm -f /boot/{.initrd,initramfs,booster,vmlinuz}*

      # Remove esp/EFI/Linux dir all its files from the sbctl database
      _remove_efi_dir
      ;;
    "")
      # Remove all known UKI files from esp/EFI/Linux dir
      _remove_all_uki
      ;;
    *)
      echo -e "${R}==>${NC} Unknown parameter ${R}$arg${NC} passed." >&2 && exit
      ;;
  esac
  echo -e "${G}==>${NC} Done."
}

# Removes all known vmlinuz and initramfs files for specified kernel
_remove_leftovers() {
  local pkgbase="$1"

  if ! _should_remove_leftovers; then return; fi

  # Remove leftovers in /boot
  rm -f /boot/.initrd-"${pkgbase}"
  rm -f /boot/vmlinuz-"${pkgbase}"
  rm -f /boot/booster-"${pkgbase}"{-fallback.img,.img}

  local force_check="${2:-0}"
  [[ "$force_check" -eq 0 ]] && return

  local uki="${EFI_DIR}/arch-${pkgbase}.efi"
  local fallback_uki="${EFI_DIR}/arch-${pkgbase}-fallback.efi"

  # Remove fallback UKI images in ESP if fallback generation is not enabled
  if ! _should_generate_fallback && [[ -e "$fallback_uki" ]]; then
    _remove_from_db "$fallback_uki"
    _remove_efi_entry "$fallback_uki" && local fallback_removed=1
    rm -f "$fallback_uki"
  fi

  if ! _should_create_efi_entry; then
    _remove_efi_entry "$uki"
    [[ "$fallback_removed" -eq 1 ]] && return
    _remove_efi_entry "$fallback_uki"
  fi
}

# Removes all known UKI files from esp/EFI/Linux dir
_remove_all_uki() {
  echo -e "${Y}::${NC} Removing ${Y}all known UKI files${NC}..."
  for pkgbase in "${pkgbases[@]}"; do
    # Remove the UKI file, vmlinuz and initramfs
    _remove_uki "$pkgbase"
  done
}

# Removes esp/EFI/Linux dir all its files from the sbctl database
_remove_efi_dir() {
  shopt -s nullglob

  # Store all EFI files in array
  local efi_files=("${EFI_DIR}"/*.efi)

  for efi_file in "${efi_files[@]}"; do
    # Remove the file from sbctl database
    _remove_from_db "$efi_file"

    # Remove EFI entries
    _remove_efi_entry "$efi_file"
  done

  # Remove esp/EFI/Linux dir
  echo -e "${Y}==>${NC} Removing ${Y}${EFI_DIR}${NC} dir..."
  rm -rf "$EFI_DIR"

  shopt -u nullglob
}

# Removes UKI file for specified kernel
_remove_uki() {
  local pkgbase="$1"
  _check_pkgbase "$pkgbase"

  # Store all UKI files in array
  readarray -t uki_files < <(find "${EFI_DIR}" \
    -type f \
    -name "arch-${pkgbase}.efi" -o \
    -name "arch-${pkgbase}-fallback.efi" 2> /dev/null)

  for uki in "${uki_files[@]}"; do
    # Remove the UKI file from sbctl database
    echo -e "${Y}==>${NC} Removing ${Y}${uki}${NC} file..."
    _remove_from_db "$uki"

    # Remove the UKI file
    rm -f "$uki"

    # Remove the EFI entry
    _remove_efi_entry "$uki"
  done

  # Remove the leftovers
  _remove_leftovers "$pkgbase"
}

# Signs the UKI file
_sign_uki() {
  local uki="$1"
  # Return if sbctl is not installed or UKI should not be signed
  if ! _command_exists sbctl || ! _should_sign_uki; then return; fi

  if [[ "$sign" -eq 0 ]]; then
    # Sbctl hook should sign the UKI file if it already exists in database
    if _in_db "$uki"; then return; fi
  fi

  # Sign UKI file with sbctl
  sbctl sign --save "$uki" || :
}

# Checks if efi entry exists
_efi_entry_exists() {
  local loader_path="$1"
  efibootmgr | grep -Fq -e "${loader_path}" -e "${loader_path^^}"
}

# Extracts the pkgbase from known UKI file path
_pkgbase_from_uki_path() {
  local uki pkgbase
  uki="$1"

  # Extract pkgbase from UKI file path
  pkgbase="${uki##*arch-}"
  pkgbase="${pkgbase%%.efi}"
  echo "$pkgbase"
}

# Formats the efi path to be readable by efibootmgr
_formatted_efi_path() {
  local efi loader_path
  efi="$1"

  # Set loader path wihout ESP mount point.
  efi_path="${efi#"$ESP_MOUNT"}"
  # Set loader path with backslashes
  efi_path="${efi_path//\//\\}"
  echo "$efi_path"
}

# Creates the EFI entry label
_create_label() {
  local pkgbase="$1"
  # Get OS NAME
  label="$(grep -Po '(?<=^NAME=").*(?=")' /etc/os-release)"
  # Set OS label to NAME + (pkgbase)
  label="${label} ($pkgbase)"
  echo "$label"
}

# Checks if Windows Boot Manager entry exists
_win_entry_exists() {
  local win_bootmg_path
  win_bootmg_path="$(find "${ESP_MOUNT}" -type f -name "bootmgfw.efi" | head -n 1)"
  [[ -z "$win_bootmg_path" ]] && return 1

  # Set formatted loader path without ESP mount point
  loader_path="$(_formatted_efi_path "$win_bootmg_path")"

  # Check if loader path exists as efi entry
  efibootmgr | grep -Fq -e "$loader_path" -e "${loader_path^^}"
}

# Preserves the old boot order
_preserve_boot_order() {
  if ! _should_preserve_boot_order; then return; fi

  # Get the boot order list
  readarray -d ',' boot_order < <(efibootmgr | grep -w "BootOrder" | sed -r 's/0+([0-9]+)/\1/g;s/BootOrder: //')
  local num_of_entries="${#boot_order[@]}"

  # If Windows Boot Manager exists and if Linux should always be first,
  # return, because efibootmgr has already added entry to the beginning of the boot order list
  if [[ "$num_of_entries" -eq 2 ]] && _linux_always_first && _win_entry_exists; then return; fi

  # Otherwise restore the old boot order without the newly added entry
  old_boot_order="$(printf "%s" "${boot_order[@]:1}")"

  # And add the newly added entry to the end of the old boot order list
  efibootmgr -o "$old_boot_order,${boot_order[0]%%,}" -q
}

# Adds the EFI entry
_create_efi_entry() {
  # Return if efibootmgr doesn't exist
  if ! _command_exists efibootmgr || ! _should_create_efi_entry; then return; fi

  local uki loader_path pkgbase
  uki="$1"

  # Extract pkgbase from UKI file path
  pkgbase="$(_pkgbase_from_uki_path "$uki")"

  # Set loader path with backslashes
  loader_path="$(_formatted_efi_path "$uki")"

  if ! _efi_entry_exists "$loader_path"; then
    local disk esp esp_number label
    # Get Efi System Partition. Example: /dev/nvme0n1p1
    esp="$(findmnt -nreo source "${ESP_MOUNT}")"

    # Get the found boot partition disk. Example: /dev/nvme0n1
    disk="/dev/$(lsblk -r -n -o PKNAME "${esp}")"

    # Get Efi System Partition number. Example: For /dev/nvme0n1p1, the number is 1
    esp_number="$(lsblk -r -n -o KNAME "${esp}")"
    esp_number="$(</sys/class/block/"${esp_number}"/partition)"

    # Set OS label to NAME + (pkgbase): Example: Arch Linux (linux)
    label="$(_create_label "$pkgbase")"

    echo -e "${B} ->${NC} Creating EFI entry ${G}${label}${NC}..."

    # Add the EFI entry
    efibootmgr --create \
      --label "${label}" \
      --disk "${disk}" \
      --part "${esp_number}" \
      --loader "${loader_path^^}" \
      --unicode -q

    # Preserve old boot order
    _preserve_boot_order
  else
    _set_linux_before_win
  fi
}

# Sets the Linux entry as the first entry before Windows
_set_linux_before_win() {
  if ! _linux_always_first; then return; fi

  # Get Windows Boot Manager efi path
  local win_bootmg_path="$(find "${ESP_MOUNT}" -type f -name "bootmgfw.efi" | head -n 1)"
  [[ -z "$win_bootmg_path" ]] && return

  # Get the boot order
  readarray -td ',' boot_order < <(printf "%s" "$(efibootmgr | grep -w "BootOrder" | sed -r 's/0+([0-9]+)/\1/g;s/BootOrder: //')")

  # Get the first boot num in the boot order
  local first_boot_num="${boot_order[0]}"

  # We do not care if only one entry exist
  [[ "${#boot_order[@]}" -eq 1 ]] && return

  # Get formatted Windows Boot Manager loader path
  loader_path="$(_formatted_efi_path "$win_bootmg_path")"

  # Get boot numbers for Windows Boot Manager entry
  readarray -t win_boot_nums < <(efibootmgr | \
    grep -Fw -e "$loader_path" -e "${loader_path^^}" | \
    awk '{ print $1 }' | \
    sed -r 's/0+([0-9]+)/\1/g;s/Boot//;s/\*//')

  # If Windows Boot Manager is the first entry in the boot order,
  # then swap the places with the nearest efi entry in the boot order list
  if printf '%s\0' "${win_boot_nums[@]}" | grep -Fqxz -- "${first_boot_num}"; then
    # Swap the places
    boot_order[0]="${boot_order[1]}"
    boot_order[1]="$first_boot_num"

    # Put the modified order in string, because efimanager needs to process it
    local new_boot_order="$(printf "%s," "${boot_order[@]}")"

    # Change the boot order with efibootmgr
    efibootmgr -o "${new_boot_order%%,}" -q
  fi
}

# Removes the EFI entry
_remove_efi_entry() {
  # Return if efibootmgr doesn't exist
  if ! _command_exists efibootmgr; then return; fi

  local uki loader_path pkgbase
  uki="$1"

  # Set loader path with backslashes
  loader_path="$(_formatted_efi_path "$uki")"

  # Find all known labels
  readarray -t labels < <(efibootmgr | \
    grep -Fw -e "$loader_path" -e "${loader_path^^}" | \
    sed 's/.*\*[[:blank:]]\(.*\)[[:blank:]]\(.*\)/\1/')

  # Find all known efibootmgr boot numbers for the specified UKI
  readarray -t boot_nums < <(efibootmgr | \
    grep -Fw -e "$loader_path" -e "${loader_path^^}" | \
    awk '{ print $1 }' | \
    sed -r 's/0+([0-9]+)/\1/g;s/Boot//;s/\*//')

  for label in "${labels[@]}"; do
    echo -e "${Y} ->${NC} Removing EFI entry ${Y}${label}${NC}..."
  done

  for boot_num in "${boot_nums[@]}"; do
    efibootmgr -b "$boot_num" -B > /dev/null
  done

  # Make sure the Linux entry is the first EFI entry before Windows on removal
  _set_linux_before_win
}

main "$@"; exit
